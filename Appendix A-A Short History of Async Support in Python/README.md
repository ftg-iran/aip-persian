# پیوست A - یک تاریخچه کوتاه از پشتیبانی async در پایتون

باوجود اینکه asyncore برای مدت زیادی بخشی از کتابخانه استاندارد پایتون بوده، ماژول asyncore
به دنبال یک API غیر قابل انعطاف انتظارات یک ماژول ناهمگام مدرن را برآورده نمی‌کرد، رنج می برد.
علاوه بر این، رویکرد آن بسیار ساده تر از آن بود که توسعه دهندگان را با تمام ابزار هایی که
بهره‌برداری کامل از پتانسیل شبکه‌های ناهمگام نیاز دارند را ارائه دهد.
محبوب ترین راه حلی که در حال حاضر در تولید استفاده می شود، استفاده از کتابخانه های شخص ثالث است. اینها
اغلب راه‌حل‌های رضایت‌بخشی را ارائه می‌دهند، اما عدم سازگاری بین این کتابخانه‌ها وجود دارد، که باعث
می‌شود کدبیس های بسیار پایدار با کتابخانه ای که استفاده میشود، جفت شود.

> - لورنس وان هاوتون [PEP 3153 (می 2011): پشتیبانی ناهمگام IO](https://peps.python.org/pep-3153/)

هدف این ضمیمه توصیف کمی از تاریخچه برنامه‌نویسی async در پایتون است، و نکته‌ای که می‌خواهم به آن اشاره کنم
– که هنوز وقتی به آن فکر می‌کنم مرا شگفت‌زده می‌کند – این است که نوآوری کلیدی که ما ۲۰ سال منتظر آن
بودیم، سینتکس زبان بود.
بسیاری از مردم از این موضوع شگفت زده خواهند شد، اما Asyncio اولین تلاشی نیست که برای افزودن پشتیبانی از
برنامه نویسی شبکه ناهمگام به پایتون انجام شده است، همانطور که در ادامه بحث می شود.

## در ابتدا asyncore وجود داشت

[در مقایسه با asyncore] Twisted تقریبا از هر جهت بهتر است. قابل حمل‌تر، جذابتر، ساده تر
مقیاس پذیرتر، توسعه پذیرتر، مستندات بهتر است و میتواند املت خوشمزه ای هم درست کند. Asyncore،
برای همه مقاصد، منسوخ شده است.

> —Glyph ca. در سال ۲۰۱۰ در [Stack Overflow](https://stackoverflow.com/questions/4384360/which-python-async-library-would-be-best-suited-for-my-code-asyncore-twisted/4385667#4385667)

<div dir="rtl">
asyncore باید به عنوان مصون تاریخی در نظر گرفته شود و هرگز از آن استفاده نشود.
</div>

> —Jean-Paul Calderone ca. در ۲۰۱۳ در [Stack Overflow](https://stackoverflow.com/questions/14698020/java-nio-server-and-python-asyncore-client/14711854#14711854)

پشتیبانی از ویژگی های به اصطلاح ناهمگام مدت ها پیش در ماژول asyncore به پایتون اضافه شد.
همانطور که از نقل قول های قبلی می توانید متوجه شوید، بازخورد نسبت به asyncore کم بود. چیزی که برای این نویسنده جذاب است، 
زمانی که این ماژول به پایتون ۱.۵.۲ اضافه شد، این همان چیزی است که بالای فایل Lib/asyncore.py در CPython نوشته شده است:

```python
# -*- Mode: Python -*-
# Id: asyncore.py,v 2.51 2000/09/07 22:29:26 rushing Exp
# Author: Sam Rushing <rushing@nightmare.com>
# =============================================================
# Copyright 1996 by Sam Rushing
```

علاوه بر این، پاراگراف اول [مستندات پایتون برای asyncore](https://docs.python.org/3/library/asyncore.html) موارد زیر را بیان می کند، که می تواند به در مستندات حال حاضر asyncio هم هست:

> این ماژول زیرساخت اولیه را برای نوشتن سرویس سوکت ناهمگام فراهم می کند.

.کلاینت ها و سرور ها

تنها دوراه برای داشتن یک برنامه در یک پردازنده وجود دارد که **بیشتر از یک کار واحد را انجام دهد**.
برنامه نویسی چند‌رشته راحترین و ساده‌ترین راه است؛ ولی تکنیک متفاوت دیگری وجود دارد که به شما
امکان داشتن تقریبا تمام مزایای چند رشته ای بدون استفاده از چند ترد را داشته باشید. این زمانی عملی است
که برنامه شما تا حد زیادی به I/O محدود باشد. اگر برنامه شما یک برنامه اگر برنامه شما به پردازنده محدود است،
رشته های برنامه ریزی شده انحصاری(__preemptive scheduled threads__) همان چیزی که نیاز دارید. با اینحال
سرور های شبکه به ندرت به پردازنده محدود می‌شوند.

<div dir="rtl">

۱۹۹۶، بله؟ واضح است که در آن زمان مدیریت همزمان چند ایونت به صورت تک رشته ای در پایتون وجود داشت.
(درواقع قبلتر از زبان های دیگر وجود داشت.) پس چه چیزی در یک ربع قرن گذشته تغییر کرده است که Asyncio اکنون خاص است؟
پاسخ سینتکس زبان است. ما دربخش بعدی این موضوع را بررسی خواهیم کرد، اما قبل از رد شدن از موضوع، ارزشش را دارد که
به جزئیات کوچکی از مستندات پایتون ۳.۶ توجه کنیم(حدودا دسامبر ۲۰۱۶):

</div>

> Source code: Lib/asyncore.py

تا نسخه ۳.۶ منسوخ می‌شود. لطفا بجای آن از asyncio استفاده کنید.

## مسیر کروتین های بومی

به یاد داشته باشید که من از اصطلاح Asyncio برای اشاره به تغییرات سینتکس پایتون و ماژول
جدید asyncio در کتابخانه استاندارد اشاره کردم. اجازه دهید بیشتر به این تمایز بپردازیم.
امروزه پشتیبانی از برنامه نویسی ناهمگان دارای سه مولفه مجزا است و جالب است بدانیم که چه زمانی آنها اضافه شدند:

*سینتکس زبان: generator ها*

> کلمه کلیدی yeild به پایتون ۲.۲(۲۰۰۱)  در [PEP 255](https://peps.python.org/pep-0255/) اضافه شد.

در نسخه ۲.۵(۲۰۰۵) در [PEP 342](https://peps.python.org/pep-0342/) با متود های send() و throw() بر
روی آبجکت های generator که اجازه میداد generator ها برای اولین بار به عنوان کروتین استفاده شوند.
کلمه کلیدی yeild از پایتون ۳.۳(۲۰۰۹) در [PEP 380](https://peps.python.org/pep-0380) برای راحتر کردن
کار با yeild های تودرتو در generator ها اضافه شد. به ویژه در مواردی که generator ها به عنوان کروتین موقت(به عنوان مثال temporary) استفاده می‌شود.

*سینتکس زبان: (کروتین)coroutines*

> کلمه کلیدی async و await در پایتون ۳.۵(۲۰۱۵) در [PEP 492](https://peps.python.org/pep-0492) اضافه شد.

که به خودی خود از کوروتین ها به عنوان یک ویژگی زبان پشتیبانی کلاس-اول می کرد
. این همچنین به این معنی است که generator ها می توانند دوباره به عنوان generator حتی در داخل توابع کوروتین استفاده شوند.

*ماژول کتابخانه: asyncio*

> در پایتون ۳.۴(۲۰۱۲) در [PEP 3156](https://peps.python.org/pep-3156) برای ارائه پشتیبانی کامل اضافه شد.

هم برای طراحان فریمورک و هم برای کاربران نهایی کار با کروتین ها و انجام دادن I/O شبکه
طراحی حلقه ایونت در asyncio در نظر گرفته شده بود تا یک پایگاه مشترک فراهم کند که
براساس آن بتوان فریمورک های شخص ثالثی مثل Tornado و Twisted استاندارد سازی شود.

این سه از هم قابل تمایز هستند. اگرچه ممکن است باعث سردرگمی شما شود زیرا دنبال کردن تاریخچه توسعه این ویژگی ها در پایتون،
سخت بوده است.
اثر گذاری سینتکس جدید async و await قابل توجه است و بر سایر زبان های برنامه نویسی نیز مانند جاوا اسکریپت، سی شارپ، اسکالا، کاتلین
و دارت تأثیر می گذارد. زمان زیادی طول کشید و هزاران برنامه نویس درگیر در پروژه پایتون فکر کردند تا ما به این نقطه برسیم.
