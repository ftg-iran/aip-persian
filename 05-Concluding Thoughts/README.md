# فصل 5 - نتیجه گیری نهایی

وقتی ویژگی های اساسی جدید در پایتون ظهور پیدا میکنند، آن ها برای همه جدید هستند. من نزدیک دو دهه تجربۀ کار با پایتون دارم؛ اما هنوز هم کتابخانه asyncio را سخت برای یادگیری میدانم. در نظر بگیرید که من با کتابخانه های Twisted و Tornado هم در پروژه های قبلی کار کرده ام، پس برنامه نویسی رویداد محور  برای من تازگی نداشت. برای من، رابط برنامه API کتابخانۀ asyncio خیلی پیچیده تر از چیزی بود که انتظار داشتم. بخشی از این بخاطر عدم وجود مستند های سطح بالا ایجاد شده بود.
حالا با گذاشتن زمان برای یادگرفتن نحوه استفاده از این کتابخانه در پایتون، بسیار احساس راحت تری با آن دارم و این فرآیند احتمال دارد برای شما هم مشابه باشد. یک ساختار منسجم و یک هدف پشت طراحی API قرار دارد و امیدوارم که این کتاب امر یادگیری را برای شما بسیار آسان تر از چیزی کند که برای من وجود داشت. با یک فهم پایه ای در مورد موضوع، حالا نوشتن کد های با این کتابخانه برای من کاملا راحت شده است؛ بدون نیاز به برگشتن به مستندات به صورت مداوم. این نشانۀ خوبی است که و قطعا برای همه ماژول های کتابخانه ها چنین چیزی رخ نمیدهد. اگر چه هنوز چند مشکل کوچک وجود دارد.
کتابخانۀ استاندارد asyncio به داشتن یک API بزرگ که به خوبی تقسیم بندی شده است ادامه خواهد داد؛ از آنجا که باید نیاز هر دو گروه کاربر نهایی و طراح چارچوب framework زا تأمین کند. این بدین معناست که ما به عنوان یک توسعه دهنده (کاربر نهایی) باید بدانیم که کدام بخش های کتابخانه برای ما کاربردی است و کدام خیر. با گذر زمان که کتابخانه های شخص ثالث برای asyncio رشد میکنند و بالغ میشوند، ما احتمالا خودمان را در حال کار با آن API ها خواهیم یافت به جای استفاده از کتابخانه خام asyncio. کتابخانه های موجود مانند aiohttp, Sanic نمونه های خوبی برای این موضوع هستند. همچنین با بیشتر شدن تجربه کار کاربران، خود asyncio هم به بهبود ادامه خواهد داد. 
من همچنین کشف های غیرمنتظره ای طی این مسیر کرده ام: با خوش شانسی، معلوم شد که نیاز است من همزمان با نوشتن این کتاب ZeroMQ هم یاد بگیرم و به این پی برده ام که ترکیب این دو کتابخانه با هم، برنامه نویسی شبکه را تبدیل به امری لذت بخش کرده است. پیشنهاد من برای بهترین روش یادگیری asyncio این است که تجربه کنید، چیزهای مختلف را امتحان کنید و خوش بگذرانید!
