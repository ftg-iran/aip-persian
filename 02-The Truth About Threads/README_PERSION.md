# واقعیت درباره رشته ها
>بیایید یک لحظه رک باشیم. شما واقعا نمی خواهید از Curio استفاده کنید. همه چیز منصفانه است،
>احتمالا باید در حال برنامه نویسی با رشته ها باشید. بله رشته ها، آن رشته ها! جدا شوخی نمی کنم.
>
>&nbsp;&nbsp;&nbsp;—دیو بیزلی, [“برنامه نویسی با Curio”](https://oreil.ly/oXJaC)

<p style='text-align: justify;'>اگر قبلا درباره رشته ها چیزی نشنیده اید، اینجا یک توضیح اساسی وجود دارد: رشته ها ویژگی های فراهم شده توسط سیستم عامل هستند که در دسترس توسعه دهندگان نرم افزار قرار گرفته اند تا به سیستم عامل نشان دهند کدام بخش های برنامه شان ممکن است به صورت موازی اجرا شوند. سیستم عامل تصمیم می گیرد چگونه منابع CPU را بین هر بخش تقسیم کند، همان طور که تصمیم می گیرد منابع CPU را بین دیگر برنامه های (پردازش ها) در حال اجرا بطور همزمان تقسیم کند.</p>

<p style='text-align: justify;'>حالا که یک کتاب Asyncio می خوانید، در اینجا باید به شما بگویم که، "رشته ها مزخرف هستند، و شما هرگز نباید از آنها استفاده کنید،" همین طوره؟ متاسفانه، این وضعیت آن قدر ها هم ساده نیست. ما باید مزایا و ریسک های استفاده از رشته ها را سبک سنگین کنیم، درست مثل انتخاب هر تکنولوژی دیگر.</p>

<p style='text-align: justify'>قرار نیست این کتاب درباره رشته ها باشد. اما اینجا دو مشکل وجود دارد: Asyncio بعنوان جایگزین threading پیشنهاد می شود، بنابراین درک ارزش این پیشنهاد بدون مقایسه دشوار است؛ و حتی موقع استفاده از Asyncio، شما احتمالا مجبور خواهید شد با رشته ها و پردازش ها سر و کله بزنید، بنابراین شما باید threading را بشناسید.</p>

>زمینه این بحث به طور منحصر به فردی در برنامه نویسی اپلیکیشن های شبکه هم زمانی دارند.
>multithreading پیشگیرانه در دامنه های دیگر نیز استفاده می شود، آن جا که تبادلات کاملا متفاوت هستند.
<hr>

## مزایای Threading

مزایای اصلی threading عبارت اند از:
- *کد خوانی راحت*
    - <p style='text-align: justify'>کد شما می‌تواند همزمان اجرا شود، اما همچنان در یک توالی خطی بسیار ساده و از بالا به پایین از دستورات تنظیم می‌شود تا جایی که - و این نکته کلیدی است - می‌توانید وانمود کنید که در بدنه توابع خود هیچ همزمانی اتفاق نمی‌افتد.</p>

- *موازی سازی با حافظه اشتراکی*
  -  <p style='text-align: justify'>کد شما می تواند از چندین CPU بهره ببرد در حالی که رشته ها هنوز حافظه مشترک دارند. برای مثال این قضیه در بسیاری از فعالیت هایی که جابجایی مقادیر زیادی داده بین فضاهای جداگانه حافظه پردازش های مختلف بسیار پرهزینه است، مهم است.</p>

- *دانش و کد موجود*
  - <p style='text-align: justify'>مجموعه وسیعی از دانش و بهترین شیوه ها برای نوشتن برنامه های کاربردی رشته ای وجود دارد. همچنین مقدار زیادی کد "مسدود کننده" وجود دارد که به multithreading برای عملیات همزمان بستگی دارد.</p>

<p style='text-align: justify'>
اکنون، با <i>پایتون</i>، این موضوع در مورد موازی بودن مشکوک است زیرا مفسر پایتون از یک قفل سراسری به نام <i>قفل مفسر سراسری</i> (GIL) برای محافظت از وضعیت داخلی خود استفاده می کند. این از اثرات فاجعه بار احتمالی شرایط مسابقه بین رشته های متعدد محافظت می کند. یکی از عوارض قفل این است که تمام رشته های برنامه شما را به یک CPU متصل می کند. همانطور که ممکن است تصور کنید، این هر گونه مزایای عملکرد موازی را نفی می کند (مگر اینکه از ابزارهایی مانند Cython یا Numba برای مانور در اطراف محدودیت استفاده کنید).
</p>
<p style='text-align: justify'>با این حال، اولین نکته در مورد سادگی درک شده بسیار مهم است: threading در پایتون <i>احساس می کند</i> فوق العاده ساده است، و اگر قبلاً توسط باگ های غیرممکن در شرایط مسابقه نسوخته اید، threading یک مدل همزمانی بسیار جذاب ارائه می دهد. حتی اگر در گذشته سوخته باشید، threading یک گزینه قانع کننده باقی می ماند زیرا احتمالاً یاد گرفته اید (از راه سخت) چگونه کد خود را ساده و ایمن نگه دارید.
</p>