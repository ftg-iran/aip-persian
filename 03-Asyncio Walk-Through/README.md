<!-- <div dir='rtl'> -->
<div dir=&quotrtl&quot>

## فصل سوم

## گشت و گذار در Asyncio

> کتاب‌خانه‌ی Asyncio ابزاری دیگر برای برنامه‌نویسی هم‌زمان در پایتون است، که از thread ها یا پردازش چندگانه سبک‌تر است. به زبان ساده، کار خود را با ایجاد یک حلقه event برای اجرای یک مجموعه از کارها انجام می‌دهد؛ با تفاوتی کلیدی که واگذاری مجدد کنترل به حلقه، به خود کار بستگی دارد.
> فیلیپ جونز، [شناخت Asyncio](https://medium.com/@pgjones/understanding-asyncio-a6592a517def)

ای‌پی‌آی asyncio پایتون پیچیده است، چرا که هدف آن حل مسائل گوناگون اقشار مختلف است. متاسفانه، تعداد راهنماهایی که به شما کمک می‌کنند دریابید که کدام بخش‌های asyncio برای تیم شما مهم است، بسیار کم است.

هدف من کمک به شما در حل موضوع بالاست. مخاطب هدف ویژگی‌های async در پایتون دو دسته‌اند:

توسعه‌دهندگان End-user:
این دسته از توسعه‌دهندگان می‌خواهند با asyncio برنامه (اپلیکیشن) بسازند. فرض می‌شود که شما در این دسته هستید.

توسعه‌دهندگان فریم‌ورک:
این دسته از توسعه‌دهندگان، فریم‌ورک‌ها و کتاب‌خانه‌هایی را می‌سازند که توسعه‌دهندگان End-user از آن‌ها در برنامه‌های خود استفاده می‌کنند.

بسیاری از سردرگمی‌ها در باره asyncio به دلیل تفاوت قائل نشدن میان دو دسته بالا از توسعه‌دهندگان است. برای مثال، مستندات رسمی پایتون برای asyncio بیشتر برای توسعه‌دهندگان فریم‌ورک است تا end-user. این یعنی که توسعه‌دهندگان end-user بعد از صرف زمان کمی برای مطالعه آن، به دلیل پیچیدگی ظاهری آن، درب و داغان می‌شوند و مانند لقمه‌ای است که پیش از جویدن باید آن را قورت دهند!

امیدوارم این کتاب به شما کمک کند که میان آن دسته از ویژگی‌های asyncio که برای هر دسته از توسعه‌دهندگان در اولویت است، تمایز قائل شوید.

اگر به جزئیات سطح پایین‌تر در مورد ساختار درونی فریم‌ورک‌های هم‌زمان مانند asyncio علاقه‌مندید، [این سخن‌رانی بی‌نظیر از دیو بیزلی](https://youtu.be/MCs5OvhV9S4) را پیش‌نهاد می‌کنم. او در این سخن‌رانی نشان می‌دهد که چگونه می‌توان نسخه‌ای ساده‌تر از فریم‌ورک ناهم‌زمانی مانند Asyncio را استفاده کرد.

هدف من ایجاد درک پایه‌ای از بنیان‌های asyncio در شماست - در اندازه‌ای که بتوانید برنامه‌های ساده‌ای با آن بنویسید و به مراجع پیچیده‌تر مراجعه کنید.

ابتدا، با ساده‌ترین چیزها شروع می‌کنیم و طی آن، مهم‌ترین اجزای ساخت برنامه‌های ساخته‌شده با asyncio را معرفی می‌کنیم.

### آغاز سریع

شما تنها به دانستن هفت تابع نیاز دارید تا به صورت معمول از asyncio استفاده کنید.

> -یوری سلیوانوف، نویسنده‌ی PEP 492، که طی آن کلیدواژه‌های async و await به پایتون افزوده شد.

عمیق‌شدن در [مستندات رسمی پایتون](https://docs.python.org/3/library/asyncio.html) به نظر ترسناک می‌آید. بخش‌های مختلف آن بسیاری مفاهیم و واژه‌های جدید دارد که حتی برای برنامه‌نویسان باتجربه‌ی پایتون نیز ناآشناست، چرا که Asyncio موضوع جدیدی در پایتون است. من قصد دارم تمام این سختی‌ها را به گام‌های کوچک تبدیل کرده و بعدتر در مورد چگونگی مطالعه این بخش از مستندات پایتون توضیح دهم، اما فعلا تنها نیاز دارید بدانید که آن بخش از این کتاب‌خانه که با آن ممکن است کار کنید، بسیار کم‌حجم‌تر از حد انتظار است.
یوری سلیوانوف، نویسنده‌ی [PEP 492](https://peps.python.org/pep-0492/) و از توسعه‌دهندگان اصلی در تمام مراحل توسعه‌ی async Python، در سخن‌رانی سال 2016 خود در پای‌کان، [async/await در پایتون 3.5 و چرایی فوق‌العاده بودنش](https://youtu.be/m28fiN9y_r8) توضیح می‌دهد که بسیاری از API ها در این ماژول برای طراحان فریم‌ورک نوشته شده و نه توسعه‌دهندگان end-user. او در این سخن‌رانی بر مواردی که توسعه‌دهندگان end-user باید به آن‌ها توجه کنند، تاکید می‌کند. این موارد بخش کوچکی از کل این ماژول هستند و در موارد زیر خلاصه می‌شوند:

<p align="right">
<div>
- شروع event loop مربوط به asyncio
</div>
<div>
- فراخوانی توابع async/await
</div>
<div>
- ایجاد یک کار برای اجرا در این حلقه
</div>
<div>
- انتظار برای اتمام چندین کار
</div>
<div>
- بستن حلقه پس از اتمام کارهای هم‌زمان
</div>
</p>

در این بخش، قصد داریم به این ویژگی‌های اساسی نگاهی بیندازیم و ببینیم چگونه می‌توانیم برنامه‌نویسی رویدادمحور را در پایتون درک کنیم و انجام دهیم.

برنامه Hello World در این ماژول در قالب مثال 3-1 آمده است:

مثال 3-1. برنامه Hello World با Asyncio

```python
# quickstart.py
import asyncio, time
async def main():
    print(f'{time.ctime()} Hello!')
    await asyncio.sleep(1.0)
    print(f'{time.ctime()} Goodbye!')
asyncio.run(main()) #1
```

<p align="right">
1. [ماژول] asyncio تابعی به نام run() دارد که توابع async و دیگر coroutine هایی را که از آن‌جا فراخوانی شده‌اند، مانند sleep()، در تابع main() اجرا می‌کند.
</p>

در زیر، خروجی مثال 3-1 آمده‌است:
          
```shell
$ python quickstart.py
Sun Aug 18 02:14:34 2019 Hello!
Sun Aug 18 02:14:35 2019 Goodbye!
```

در عمل، بیشتر کدهای asyncio-محور شما از تابع run() که در این‌جا نشان داده شده، استفاده می‌کند، اما مهم است که اندکی بیشتر در مورد کاری که این تابع برای شما انجام می‌دهد بدانیم. این دانش از آن جا اهمیت دارد که در طراحی‌های کلان نرم‌افزاری شما تاثیر می‌گذارد.

مثال 3-2 کدی است که من آن را «شبه hello world» می‌نامم. دقیقا کار run() را انجام نمی‌دهد، اما به قدر کافی ایده‌هایی که طی این کتاب به آن‌ها خواهیم پرداخت را معرفی می‌کند. [برای فهم آن] نیاز به دانشی پایه‌ای از coroutine ها (که عمیقا در بخش‌های بعدی این فصل به آن می‌پردازیم) دارید، اما به هر جهت تلاش کنید با آن پیش رفته و فعلا بر مفاهیم سطح بالا تمرکز کنید.

مثال 3-2. شبه hello world با asyncio

```python
# quickstart.py
import asyncio
import time
async def main():
    print(f"{time.ctime()} Hello!")
    await asyncio.sleep(1.0)
    print(f"{time.ctime()} Goodbye!")
loop = asyncio.get_event_loop() #1
task = loop.create_task(main()) #2
loop.run_until_complete(task) #3
pending = asyncio.all_tasks(loop=loop)
for task in pending:
    task.cancel()
group = asyncio.gather(*pending, return_exceptions=True) #4
loop.run_until_complete(group) #3
loop.close() #5
```

<p align="right">
<div>
1. `loop = asyncio.get_event_loop()`
</div>
<div>
- شما نیاز دارید که یک event loop پیش از اجرای هر coroutine ایجاد کنید. این متد در واقع، تا زمانی که از یک thread استفاده کنید، هر بار همان حلقه‌ی وابسته به آن را   برمی‌گرداند. اگر داخل یک تابع async def باشید، باید تابع `asyncio.get_running_loop` را فراخوانی کنید، که نتیجه مورد انتظارتان را برمی‌گرداند. این موضوع با جزئیات بسیار بیشتر در بخش‌های بعدی کتاب پوشش داده می‌شود.
</div>
<div>
2. `task = loop.create_task(coro)`
<div>
- در این حالت، باید به طور خاص `loop.create_task(main())` را فراخوانی کنید. تابع coroutine شما تا زمانی که این کار را انجام ندهید، اجرا نمی‌شود. با این کار، تابع coroutine شما با حلقه اجرا می‌شود. شئ از نوع task ای که برگردانده می‌شود، می‌تواند در ره‌گیری وضعیت تسک استفاده شود (مثلا این که تسک هنوز در حال اجراست یا خاتمه پیدا کرده‌است) یا نتیجه اجرای coroutine تمام‌شده را بدهد. می‌توانید تسک را با متد `task.cancel()` متوقف کنید.
</div>
<div>
3. `loop.run_until_complete(coro)`
</div>
<div>
- فراخوانی این تابع، thread در حال اجرا را - که معمولا thread  اصلی است - متوقف می‌کند. توجه داشته باشید که `run_until_complete()` تنها تا زمانی حلقه را در حال اجرا نگه می‌دارد که  coroutine داده شده کامل شود، اما دیگر تسک‌هایی که برای اجرا در حلقه تنظیم شده‌اند، تا زمانی که حلقه در حال اجراست، اجرا می‌شوند. در پشت صحنه، `asyncio.run()` تابع `run_until_complete()` را فراخوانی کرده و به این ترتیب thread اصلی را به شکلی که توضیح داده شد متوقف می‌کند.
</div>
<div>
4. `group = asyncio.gather(task1, task2, task3)`
</div>
<div>
- زمانی که قسمت main برنامه از توقف، چه به دلیل سیگنالی از سوی پردازش یا توقف حلقه به دلیل فراخوانی loop.stop() از سوی قطعه کدی دیگر، بیرون می‌آید، کدِ پس از `run_until_complete()` اجرا می‌شود. استاندارد معمول، مطابق آن چه در کد بالا آمده، این است که تسک‌های در صف انتظار را مجتمع کنیم، متوقف کنیم و سپس با استفاده مجدد از `loop.run_until_complete()` آن‌ها را انجام دهیم. متد gather() کار جمع‌آوری را انجام می‌دهد. توجه داشته باشید که asyncio.run() تمام کار متوقف‌کردن، جمع‌آوری و انتظار برای تسک‌های در صف تا خاتمه‌ی آن‌ها را انجام می‌دهد.
</div>
<div>
5. `loop.close()`
</div>
<div>
- این متد معمولا حرکت نهایی است: باید بر روی یک حلقه‌ی متوقف‌شده فراخوانی شود. طی آن، تمام صف‌ها پاک شده و اجراکننده خاموش می‌شود. حلقه‌ی متوقف‌شده را می‌توان از نو به کار گرفت، اما حلقه‌ی بسته‌شده برای همیشه از بین می‌رود. پشت صحنه، asyncio.run() حلقه را پیش از بازگرداندن [مقدار مد نظر] می‌بندد. این موضوع مسئله‌ای ندارد، چرا که run() حلقه‌ی event جدیدی را با هربار فراخوانی ایجاد می‌کند.
</div>
</p>
مثال 3-1 نشان می‌دهد که اگر از asyncio.run() استفاده کنید، هیچ کدام از مراحل گفته‌شده را لازم نیست طی کنید. با این حال، مهم است که این مراحل را بفهمیم، چرا که شرایط در عمل پیچیده‌تر می‌شود و شما برای درگیری با چالش‌ها به دانش بیشتری نیاز دارید. بسیاری از این مراحل در قسمت‌های بعدی کتاب ، با جزئیات پوشش داده شده‌اند.
مثال قبل ساده‌تر از آن است که بتواند در عمل به کار بیاید. اطلاعات بیشتری برای ازکارانداختن اصولی [حلقه‌ها] نیاز است. هدف این مثال تنها این بود که مهم‌ترین توابع و متدها را در asyncio معرفی کند. اطلاعات بیشتر و کاربردی در فصل «بالاآوردن و از کارانداختن اصولی» در صفحه 57 آمده است.
این کتاب، مطالب بسیاری را در مورد پشت صحنه‌ی event loopها بیان می‌کند، و از شما می‌خواهد که از مواردی مانند مدیریت چرخه کار آگاهی داشته باشید. این مورد در Node.js متفاوت است - که مثلا، مانند asyncio یک event loop اجرا می‌کند اما تا حدودی آن را از دید توسعه‌دهنده پنهان می‌کند. با این حال، پس از این که قدری با asyncio کار کنید، متوجه می‌وید که الگوی بالاآوردن و ازکارانداختن event loopها، چندان هم از چیزی که در مثال‌ها مطرح شده دور نیست. تعدادی از ریزه‌کاری‌های مدیریت چرخه کار حلقه‌ها را با جزئیات بیشتر، بعدا بررسی خواهیم‌کرد.
من چیزی را از مثال قبل جا گذاشتم. آخرین چیزی که در مورد عمل‌کرد پایه باید بدانید، اجرای توابع متوقف‌کننده است. موضوع در باب چندکارگی همکارانه (cooperative multitasking) این است که نیاز داریم تمام توابع وابسته به ورودی/خروجی خب...با هم هم‌کاری کنند! این بدان معناست که اجازه دهیم چارچوب پشت صحنه، کنترلش با کلیدواژه await به حلقه منتقل شود. بیشتر کدهای پایتون در این روزها این کار را نمی‌کنند و به جای آن، تکیه بر این می‌کنند که چنین توابعی را در thread ها اجرا کنید. تا زمانی که پشتیبانی گسترده‌تری از توابع async نشود، درک خواهید کرد که استفاده از کتاب‌خانه‌ها برای توقف  توابع غیر قابل اجتناب است.

برای این کار، ماژول asyncio یک API بسیار شبیه به APIای که در بسته‌ی `concurrent.features` است، ارائه می‌کند. این بسته یک ThreadPoolExecutor و یک ProcessPoolExecutor در خود دارد. پیش‌فرض آن thread-محور است، اما هر کدام از اجراکننده‌های thread-محور یا پردازش محور می‌تواند استفاده شود. من از مسائل مربوط به اجراکننده در مثال قبل صرف نظر کردم، چرا که توصیف چگونگی جورشدن اجزای بنیادی با یک‌دیگر را پیچیده می‌کند. حال که تمام آن موضوعات پوشش داده شده، می‌توانیم مستقیما با این موضوع روبرو شویم.

تعدادی فوت کوزه‌گری وجود دارد که باید به آن‌ها توجه نمود. با هم قطعه کدی که در مثال 3-3 آمده را ببینیم:

مثال 3-3: واسط پایه‌ای اجراکننده

```python
# quickstart_exe.py
import time
import asyncio
async def main():
    print(f'{time.ctime()} Hello!')
    await asyncio.sleep(1.0)
    print(f'{time.ctime()} Goodbye!')
def blocking(): #1
    time.sleep(0.5) #2
    print(f"{time.ctime()} Hello from a thread!")
loop = asyncio.get_event_loop()
task = loop.create_task(main())
loop.run_in_executor(None, blocking) #3
loop.run_until_complete(task)
pending = asyncio.all_tasks(loop=loop) #4
for task in pending:
    task.cancel()
group = asyncio.gather(*pending, return_exceptions=True)
loop.run_until_complete(group)
loop.close()
```

<ol dir="rtl">
<li>
متد `blocking()` تابع سنتی time.sleep() درون خود فراخوانی می‌کند، که thread اصلی را متوقف کرده و event loop شما را از اجرا باز می‌دارد. این بدان معناست که شما نباید این تابع را  در جایگاه یک coroutine قرار دهید - در واقع، شما در هیچ‌کجای thread اصلی، که حلقه‌ی مربوط به asyncio در حال اجراست، نمی‌توانید این تابع را فراخوانی کنید. این مسئله به وسیله‌ی اجرای این تابع در یک اجراکنند حل می‌شود.
</li>
<li>
موضوعی که در این مورد بیان می‌شود، مربوط به این بخش نیست، اما برای بخش‌های بعد به کار می‌آید: توجه کنید که در main() زمان sleep در حالت توقف (نیم ثانیه) بیشتر از زمان sleep در حالت بدون توقف است (یک ثانیه). این کار، کد را مرتب و تمیز نگه می‌دارد. در «انتظار برای اجراکننده در حین خاموش شدن»، صفحه 68، به این خواهیم پرداخت که در صورت طولانی‌تر شدن زمان اجرای توابع اجراکننده از همتایان async شان در طی از کار افتادن، چه اتفاقی می‌افتد.
</li>
<li>
جزء `await loop.run_in_executor(None, func)` آخرین مورد در لیست موارد پراهمیت ما است. گاهی اوقات نیاز است که کدها را در چارچوب یک thread یا حتی یک پردازش جداگانه اجرا کرد: این متد دقیقا برای همین کار است. در این‌جا تابع متوقف‌کننده را ورودی می‌دهیم تا در اجراکننده‌ی اصلی اجرا شود. توجه کنید که  `run_in_executor()` خود thread اصلی را متوقف نمی‌کند: تنها به اجراکننده تسکی می‌دهد تا اجرا کند (یک شئ از جنس Future برمی‌گرداند، بدان معنا که می‌توانید در صورتی که در یک تابع coroutine دیگر فراخوانی شود، منتظر نتیجه‌ی آن بمانید). کار اجراکننده فقط زمانی شروع می‌شود که `run_until_complete()`، که اجازه می‌دهد event loop شروع به کار کند، فراخوانی شود.
</li>
<li>
نکته‌ای دیگر بر مورد دوم: مجموعه‌ی تسک‌های در انتظار اجرا، شامل جایی برای فراخوانی blocking() در run_in_executor نیست. این موضوع شامل هر فراخوانی که به جای Task، شئ Future برمی‌گرداند، صادق است. مستندات اصلی کیفیت نسبتا خوبی در تمییز میان تایپ اشیای بازگردانی‌شده دارد، و می‌توانید تایپ شئ بازگردانی‌شده را آن‌جا ببینید؛ تنها به یاد داشته باشید که all_tasks() فقط و فقط Task برمی‌گرداند و نه Future.
</li>
</ol>

خروجی زیر مربوط به اجرای مثال قبل است:

```shell
$ python quickstart_exe.py
Sun Aug 18 01:20:42 2019 Hello!
Sun Aug 18 01:20:43 2019 Hello from a thread!
Sun Aug 18 01:20:43 2019 Goodbye!
```

حال که موارد اصلی asyncio برای استفاده‌ی توسعه‌دهندگان end-user را آموختید، زمان آن فرارسیده که دامنه‌ی یادگیری خود را گسترش دهیم و asyncio API را در قالب یک سلسله مراتب بیان کنیم. این کار، فهم استفاده‌ی بهینه از مستندات را آسان‌تر می‌کند.

## بیان سلسله مراتبی Asyncio

همان‌طور که در بخش قبل دیدید، تنها نیاز است بخشی از دستورات asyncio را برای کار با آن به عنوان توسعه‌دهنده‌ی end-user بدانید. متاسفانه، مستندات این کتاب‌خانه تعداد زیادی API را معرفی می‌کند و این کار را چنان بدون دسته‌بندی انجام می‌دهد که دشوار است بتوان گفت که چه چیزهایی برای استفاده‌ی روزمره است و چه چیزهایی برای استفاده‌ی طراحان فریم‌ورک.

طراحان فریم‌ورک که همین مستندات را مطالعه می‌کنند، به دنبال نقاط اتصالی هستند که بتوانند به آن‌ها، فریم‌ورک‌های جدید یا کتاب‌خانه‌های شخص ثالث خود را متصل کنند. در این بخش، از دید یک طراح فریم‌ورک به asyncio می‌نگریم تا حسی از مسیر ساخت یک کتاب‌خانه‌ی سازگار با async پیدا کنیم. امیدواریم که این کار، توضیحات بیشتری برای مواردی که در کار به آن‌ها نیاز پیدا می‌کنید، باشد.

بر اساس این دیدگاه،، خوب است که ماژول asyncio را، به جای یک لیست بدون دسته‌بندی، در قالب یک سلسله مراتب ببینیم، که در آن هر سطح، بر پایه‌ی مواردی از سطح پایین‌تر از خود ساخته می‌شود. البته این دسته‌بندی چندان هم با نظم و ترتیب نیست و من قدری سلیقه‌ی شخصی را نیز در آن دخالت داده‌ام. اما امیدوارم این سلسله مراتب، دید دیگری از ای‌پی‌آی asyncio به شما بدهد.

جدول 3-1، و نام‌ها و مراتب آن، تماما ساخته‌ی من است و تنها برای ساختارمندتر کردن توضیح‌دادن asyncio است. خواننده‌ی متبحر ممکن است موارد را به ترتیب دیگری دسته‌بندی کند. ایرادی بر آن وارد نیست!

جدول 3-1: موارد موجود در asyncio در قالب یک سلسله‌مراتب، برای توسعه‌دهندگان end-user.
Level | Concept | Implementation |
--- | --- | --- |
**Tier 9** | **Network: streams** | StreamReader, StreamWriter, asyncio.open_connection(), asyncio.start_server() |
Tier 8 | Network: TCP & UDP | Protocol|
Tier 7 | Network: transports| BaseTransport|
**Tier 6** | **Tools** | asyncio.Queue|
**Tier 5** | **Subprocesses & threads** | run_in_executor(), asyncio.subprocess|
Tier 4 | Tasks | asyncio.Task, asyncio.create_task()|
Tier 3 |Futures | asyncio.Future|
**Tier 2** |**Event loop**| asyncio.run(), BaseEventLoop|
**Tier 1 (Base)** |**Coroutines**| async def, async with, async for, await|

در بنیادی‌ترین سطح، سطح 1، ما coroutine هایی را داریم که تا کنون در این کتاب دیده‌اید. این‌جا پایه‌ای‌ترین سطحی است که می‌توان از آن برای طراحی یک فریم‌ورک شخص ثالث شروع به کار کرد. به طرز جالبی، این بخش برای نه یک، که دو فریم‌ورک async موجود، [Curio](https://github.com/dabeaz/curio) و [Trio](https://github.com/python-trio/trio). هر دوی این‌ها تنها برا coroutine های خود پایتون تکیه دارند و از چیزی در asyncio استفاده نمی‌کنند.

سطح بعدی، حلقه‌های event هستند. Coroutine ها به خودی خود استفاده‌ای ندارند: آن‌ها بدون حلقه‌ای که ازشان برای اجرا استفاده کند، کاری نمی‌کنند (بنابراین، Curio و Trio حتما حلقه‌های event خود را پیاده کرده‌اند). Asyncio نوعی از حلقه به نام `AbstractEventLoop` و یک پیاده‌سازی از آن به نام ‌`BaseEventLoop` را در خود دارد.

جداسازی صریح میان نوع و پیاده‌سازی این امکان را برای توسعه‌دهندگان [نرم‌افزارهای] شخص ثالث فراهم می‌کنند که بتوانند پیاده‌سازی‌های جایگزینی از حلقه‌های event انجام دهند. این کار در پروژه‌ی uvloop انجام شده‌است. حلقه‌ی event دراین پروژه، بسیار از حلقه‌ی استاندارد asyncio سریع‌تر است. مهم این که، [uvloop](https://github.com/MagicStack/uvloop) تنها نفوذی در این سطح‌بندی انجام داده و بخش حلقه‌ی آن را تغییر می‌دهد. امکان ایجاد چنین تغییراتی، دقیقا دلیل طراحی این چنینی asyncio با جداسازی‌های صریح میان اجزای محرک است.

سطح‌های 3 و 4 تسک‌ها و future ها را معرفی می‌کنند. این دو بسیار به هم مرتبطند؛ جدایی آن‌ها به دلیل زیرکلاس بودن Task برای Future است، اما این دو به راحتی می‌توانند در یک سطح به حساب بیایند. یک شی از نوع Future نماینده‌ی یک کار در حال اجرا است که از طریق اعلان، نتیجه‌ی خود را در حلقه‌ی event برمی‌گرداند، در حالی که یک Task نماینده‌ی یک coroutine است که روی حلقه‌ی event در حال اجراست. کوتاه‌تر بگوییم، Future «حلقه‌محور» است، در حالی که Task هم حلقه‌محور و هم «coroutineمحور» است. به عنوان یک توسعه‌دهنده‌ی end-user، بیش از آن که با futureها کار کنید، با Taskها کار خواهیدکرد، اما اگر طراح فریم‌ورک باشید، نسبت استفاده از این دو، بسته به جزئیات، فرق می‌کند.

سطح 5 نمایان‌گر ابزارهای مورد نیاز برای اجرا و انتظار برای اتمام کاری است که در یک thread یا حتی پروسه‌ی جداگانه در حال انجام است.

سطح 6 ابزارهای asyncمحور بیشتری مانند asyncio.Queue را معرفی می‌کند. این سطح را می‌توانستم پس از سطح شبکه قرار دهم، اما فکر می‌کنم که منظم‌تر است ابتدا تمام APIهای coroutineمحور را پیش از مواجهه با لایه‌های I/O یاد بگیریم. Queue ای که asyncio ارائه می‌دهد، APIای مشابه صف thread-safe در ماژول queue دارد، با این تفاوت که در asyncio برای متدهای get() و put() کلیدواژه‌ی async را در ابتدایشان لازم دارد. نمی‌توان از queue.Queue مستقیما درون coroutine ها استفاده کرد، چرا که متد get() آن thread اصلی را متوقف می‌کند.

و درنهایت، سطوح 7تا9 را که متعلق به ورودی و خروجی‌های شبکه هستند، داریم. به عنوان یک توسعه‌دهنده‌ی end-user، مطمئن‌ترین API برای کار با آن، streams API در سطح 9 است. من streams API را در بالاترین سطح از نظر انتزاع [و ساده‌تر برای فهم] قرار داده‌ام. protocols API، که دقیقا در یک سطح پایین‌تر از آن قرار دارد (سطح 8)، API پرجزئیات‌تری است؛ می‌توانید از protocols به جای streams استفاده کنید، اما استفاده از streams ساده‌تر است. سطح آخر I/Oی شبکه، سطح انتقال (transport) است (سطح 7). احتمال این‌که شما مستقیما با آن کار کنید، کم است، مگر این که بخواهید فریم‌ورکی برای استفاده‌ی آزاد بسازید و نیاز باشد چگونگی تنظیم انتقالات را درست کنید.

در «شروع سریع»، صفحه22، کمترین چیزهایی که برای شروع به کار با کتاب‌خانه‌ی asyncio نیاز است را مشاهده کردیم. حال که نگاهی به کلیت اجزای این کتاب‌خانه انداختیم، خوب است که لیست مجتمعی از ویژگی‌های آن را مرور کنیم و بر بخش‌هایی که احتمالا نیاز دارید یاد بگیرید، تاکید کنیم.

این موارد مهم‌ترین‌ها در یادگیری استفاده از کتاب‌خانه‌ی asyncio برای نوشتن برنامه‌های شبکه هستند:

سطح 1

<ul>
<li>
درک چگونگی نوشتن توابع async و استفاده از await برای فراخوانی و اجرای coroutine ها اهمیت دارد. 
</li>
</ul>
سطح 2
<ul>
<li>درک چگونگی بالاآوردن، از کار انداختن و کار کردن با حلقه‌ی event اهمیت دارد. </li>
</ul>
سطح 5
<ul>
<li>
اجراکننده‌ها برای متوقف‌کردن کد در برنامه‌ی async شما نیازند، و واقعیت این است که بیشتر کتاب‌خانه‌های شخص ثالث هنوز با asyncio سازگار نیستند. مثالی خوب از این مورد، کتاب‌خانه‌ی ORM از پایگاه داده‌ی SQLAlchemy، که هنوز برای آن هیچ جایگزین بهتری که سازگار با asyncio باشد، موجود نیست. 
</li>
</ul>
سطح 6
<ul>
<li>
اگر نیاز دارید به coroutineهایی که حداقل یک بار و هر بار به مدت طولانی اجرا می‌شوند، داده ورودی بدهید، بهترین راه برای انجام آن، استفاده از asyncio.Queue است. این کار دقیقا مشابه استفاده از queue.Queue برای توزیع داده بین threadهاست. نسخه‌ی asyncioی آن از همان  API ای استفاده می‌کند که ماژول استاندارد queue، با این تفاوت که از coroutineها به جای متدهای متوقف‌کننده‌ای مانند get() استفاده می‌کند. 
</li>
</ul>
سطح 9
<ul>
<li>
ای‌پی‌آی streams ساده‌ترین راه برای مدیریت ارتباطات سوکت در شبکه است، و در این‌جاست که باید برای برنامه‌های شبکه ایده‌پردازی کنید. می توانید ببینید که مدیریت دقیق‌تری نیاز است، و بعد به protocols API تغییر مسیر دهید. اما در بیشتر پروژه‌ها بهتر است تا زمانی که بدانید چه مسئله‌ای را دارید حل می‌کنید، چیزها را ساده انجام دهید. 
</li>
</ul>

البته، اگر از کتاب‌خانه‌ی سازگار با asyncioی شخص ثالثی استفاده می‌کنید که تمام ارتباطات سوکت را برای شما مدیریت می‌کند - مانند aiohttp - نیازی نیست مستقیما با لایه‌های شبکه کار کنید. در این حالت، باید تکیه‌ی زیادی به مستندات ارائه‌شده برای کتاب‌خانه‌ی [مورد استفاده‌تان] داشته باشید.

در بخش‌های بعدی، بخش‌هایی که در بالا فهرست شده‌اند را با جزئیات بیشتری بررسی می‌کنیم.

سایت [pysheeet](https://www.pythonsheets.com/notes/python-asyncio.html) خلاصه‌ای عمیق (یا برگه تقلب) از بخش‌های کلی syncio ارائه کرده‌است؛ هر بخش کدی کوتاه به عنوان مثال دارد. این برگه بسیار پرجزئیات است و برای مبتدی‌ها پیشنهاد نمی‌شود، اما اگر تجربه‌ی برنامه‌نویسی پایتون دارید و از آن دسته افرادی هستید که اطلاعات جدید ارائه‌شده در قالب کد را سریع می‌گیرید، این سایت می‌تواند منبع خوبی باشد.

## متدهای Coroutine

از ابتدا شروع کنیم: coroutine چیست؟

هدف من در این بخش این است که معنی دقیق اصطلاحاتی مانند شئ coroutine و تابع غیرهم‌زمان (asynchronous) را متوجه شوید. مثال‌های که در این‌جا می‌آیند، تعاملات سطح پایینی را نشان می‌دهند که معمولا در اکثر برنامه‌ها نیاز نیست؛ در عین حال، به فهم شما از بخش‌های بنیادی asyncio عمق می‌بخشند و یادگیری بخش‌های بعدتر را ساده‌تر می‌کنند.

مثال‌ها می‌توانند در مفسر پایتون نسخه 3.8 و حالت تعاملی اجرا شوند. از شما خواهش می‌کنم که آن‌ها را خود تایپ کنید، خروجی‌ها را مشاهده کنید، و در صورت امکان، با راه‌های مختلف تعامل با async و await بازی کنید.

ماژول asyncio اولین بار در نسخه 3.4 پایتون اضافه شد، اما دستور جدید برای coroutineها و async def و await در نسخه‌ی 3.5 اراده شدند. پیش از این، دیگران چگونه با asyncio کار می‌کردند؟ از generatorها به گونه‌ی مخصوصی استفاده می‌کردند که گویی coroutine اند! در مجموعه کدهای قدیمی‌تر، توابع generator را می‌بینید که دکوراتور `@asyncio.coroutine` را دارند و در آن‌ها yield from به کار رفته‌است. coroutineهایی که با async def ساخته شده‌اند، به عنوان اصل مبنا قرار می‌گیرند، چرا که در زبان تنها به همین عنوان نوشته شده‌اند. در این کتاب، از پرداختن به coroutineهای generatorمحور قدیمی صرف نظر می‌شود.

## کلیدواژه‌ی جدید async def

مثال 3-4: توابع async تابعند و نه coroutine

```python
>>> async def f(): #1
...     return 123
...
>>> type(f) #2
<class 'function'>
>>> import inspect #3
>>> inspect.iscoroutinefunction(f) #4
True
```

<ol>
<li>
مثال بالا، ساده‌ترین راه ایجاد یک coroutine است: شبیه یک تابع عادی، با این تفاوت که با async def شروع می‌شود.
</li>
<li>
عجب! نوع دقیق f، یک coroutine نیست! بلکه تنها یک تابع معمولی است. با وجود این که رایج است به توابع async def، coroutine گفته شود، اما پایتون آن‌ها را «توابع» coroutine می‌بیند. کد بالا شبیه کارکرد توابع generator در پایتون است:
</li>

```python
>>> def g():
...     yield 123
...
>>> type(g)
<class 'function'>
>>> gen = g()
>>> type(gen)
<class 'generator'>
```

<li style="list-style-type: disc">
اگر چه g به غلط گاهی generator خوانده می‌شود، یک تابع می‌ماند و تنها در زمان اجرا generator بارگردانده می‌شود. توابع coroutine دقیقا همین طور کار می‌کنند: نیاز است تابع async def را برای دریافت شئ coroutine فراخوانی کنید.
</li>
</ol>
<ol start="3">
<li>
ماژول inspect در کتاب‌خانه‌ی استاندارد، ظرفیت‌های بهتری برای بررسی درونی برنامه‌ها نسبت به تابع توکار type() به دست می‌دهد. 
</li>
<li>
تابعی به نام iscoroutinefunction() وجود دارد که به شما این امکان را می‌دهد که تمایز بین یک تابع معمولی و یک coroutine را ببینید.
</li>
</ol>

مجدد به تابع async def خود، f() باز می‌گردیم. مثال 3-5 نشان می‌دهد که طی فراخوانی آن چه اتفاقی می‌افتد.

مثال 3-5. یک تابع async def، شیئی آز جنس coroutine برمی‌گرداند.

```python
>>> coro = f()
>>> type(coro)
<class 'coroutine'>
>>> inspect.iscoroutine(coro)
True
```

به سوال اصلی خود باز می‌گردیم: یک coroutine دقیقا چیست؟ شیئی است که امکان ادامه‌ی اجرای یک تابع پشت صحنه را که پیش از تکمیل کارش معلق شده‌است، فراهم می‌کند. آشنا به چشم آمدن این مفهوم به این دلیل است که coroutineها بسیار شبیه به generator عمل می‌کنند. البته که، پیش از معرفی coroutine های فعلی و کلیدواژه‌های async def و await در پایتون 3.5، این امکان وجود داشت که از کتاب‌خانه‌ی asyncio با استفاده از generator های رایج و دکوراتورهای مخصوص استفاده کرد. جای تعجب ندارد که توابع جدید async def (و coroutine هایی که برمی‌گردانند)، مشابه generator ها رفتار کنند.

می‌توان قدری بیشتر با اشیاء coroutine بازی کرد تا بهتر بتوان درک کرد که پایتون چگونه از آن‌ها استفاده می‌کند. مهم‌ترین موضوع این است که، می‌خواهیم ببینیم پایتون چگونه بین اجراهای coroutineهای مختلف رفت و آمد می‌کند. ابتدا به چگونگی حاصل شدن مقدار برگشتی می‌نگریم.

زمانی که یک coroutine مقداری را برمی‌گرداند، آن‌چه واقعا اتفاق می‌افتد، ایجادشدن یک استثنای StopIteration است. مثال 3-6، که در همان چارچوب مثال‌های قبلی ادامه می‌یابد، این موضوع را آشکار می‌کند.

مثال 3-6. درون یک coroutine: استفاده از send() و StopIteration

```python
>>> async def f():
...     return 123
>>> coro = f()
>>> try:
...     coro.send(None) #1
... except StopIteration as e:
...     print('The answer was:', e.value) #2
...
The answer was: 123
```

<ol>
<li>
یک coroutine با ارسال شیئی از جنس None به آن، ایجاد می‌شود. پشت صحنه، این، کاری است که حلقه‌ی event با coroutine ها انجام می‌دهد؛ شما هرکز نیازی نخواهید داشت که آن را دستی انجام دهید. تمام coroutineهایی که می‌سازید یا با loop.create_task(coro) یا await coro اجرا می‌شود. این حلقه‌ی event است که پشت صحنه، send(None) را اجرا می‌کند. 
</li>
<li>
زمانی که coroutine مقداری را برمی‌گرداند، نوع خاصی از استثنا به نام StopIteration ایجاد می‌شود. دقت کنید که می‌توان به مقدار بازگردانده شده از طریق متغیر value ی استثنا دسترسی داشت. این‌جا هم، نیازی به دانستن این کارکردها نیست: از دید شما، توابع async def مقداری را با دستور return، مانند توابع عادی، باز می‌گردانند.
</li>
</ol>

این دو نکته، send() و StopIteration، شروع و پایان coroutine در حال اجرا را تعریف می‌کنند. تا این‌جا، به نظر می‌آید که این روش اجرای توابع بسیار پیچیده است، اما مسئله‌ای نیست: حلقه‌ی event مسئول اجرای coroutine با دستورات درونی گفته‌شده است. از دید شما، coroutine ها فقط برای اجرا در حلقه برنامه‌ریزی شده و به صورت بالا به پایین، تقریبا شبیه توابع معمولی، اجرا می‌شوند.

قدم بعدی آشنایی با معلق کردن اجرای یک coroutine است.

## کلیدواژه‌ی جدید await

این کلیدواژه همواره یک پارامتر می‌گیرد و تنها چیزی را قبول می‌کند که awaitable باشد. یک awaitable دقیقا یکی از دو مورد زیر است:

<ul dir="rtl">
<li>
یک coroutine (یا به عبارت دیگر، نتیجه‌ی فراخوانی تابع async def)
</li>
<li>
هر شیئی که متد انحصاری await() را پیاده‌سازی کند. این متد انحصاری باید یک پیمایش‌گر (iterator) بازگرداند. 
</li>
</ul>

توضیحات مربوط به نوع دوم از بحث این کتاب خارج است (هرگز در برنامه‌نویسی روزمره‌ی asyncio به آن نیازی پیدا نمی‌کنید)، اما نوع اول، همان‌طور که در مثال 3-7 آمده، بسیار سرراست است.

مثال 3-7. استفاده از await بر سر یک coroutine

```python
async def f():
    await asyncio.sleep(1.0)
    return 123
async def main():
    result = await f() #1
    return result
```

<ol dir="rtl">
<li>
فراخوانی f() یک coroutine ایجاد می‌کند؛ این بدان معناست که می‌توانیم آن را await کنیم (به انتظار اجرای آن بنشینیم). مقدار متغیر result پس از اتمام اجرای f()، 123 خواهدبود.
</li>
</ol>

پیش از خاتمه‌ی این بخش و شروع توضیحات event loop سودمند است که ببینیم چگونه می‌توان به coroutine ها استثنا خوراند. این مورد بسیار در متوقف‌سازی استفاده می‌شود: زمانی که task.cancel() را فراخوانی می‌کنید، حلقه‌ی event پشت صحنه coro.throw() را استفاده کرده تا asyncio.CancelledError را درون coroutine ایجاد کند (مثال 3-8).

مثال 3-8. استفاده از coro.throw() برای تزریق استثنا در یک coroutine

```python
>>> coro = f() #1
>>> coro.send(None)
>>> coro.throw(Exception, 'blah') #2
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
 File "<stdin>", line 2, in f
Exception: blah
blah
```

<ol>
<li>
مانند قبل، یک coroutine جدید از f()، تابع coroutine، ساخته می‌شود.
</li>
<li>
به جای یک send() دیگر، throw() را فرامی‌خوانیم و یک کلاس استثنا و یک مقدار ایجاد می‌کنیم. این کار یک استثنا درون coroutine و در نقطه‌ی await ایجاد می‌کند. 
</li>
</ol>

متد throw() در درون asyncio برای متوقف‌کردن تسک استفاده می‌شود. این را به سادگی نشان خواهیم داد. در مثال 3-9 حتی از این هم فراتر خواهیم رفت و استثنای ایجادشده را درون یک coroutine جدید مدیریت می‌کنیم.

```python
>>> import asyncio
>>> async def f():
...     try:
...         while True: await asyncio.sleep(0)
...     except asyncio.CancelledError: #1
...         print('I was cancelled!') #2
...     else:
...         return 111
>>> coro = f()
>>> coro.send(None)
>>> coro.send(None)
>>> coro.throw(asyncio.CancelledError) #3
I was cancelled! #4
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
StopIteration #5
```

<ol>
<li>
حال تابع coroutine ما یک استثنا را مدیریت می‌کند. در واقع، استثنای منحصربه‌فردی را مدیریت می‌کند که در کتاب‌خانه‌ی asyncio برای متوقف‌کردن تسک‌ها استفاده می‌شود: asyncio.CancelledError. دقت کنید که استثنا از بیرون به coroutine تزریق می‌شود (از طریق event loop، که با آن هم‌چنان در حال شبیه‌سازی دستی توابع send() و throw() هستیم). در کد واقعی، که جلوتر خواهیددید، CancelledError در زمان متوقف‌شدن تسک‌ها درون coroutine داخل یک تسک ایجاد می‌شود.
</li>
<li>
این خط پیامی ساده است برای اطلاع‌رسانی توقف تسک. دقت کنید که با مدیریت استثنا، مطمئن می‌شویم که دیگر پیش نرفته و coroutine مقداری را بازمی‌گرداند. 
</li>
<li>
در این‌جا استثنای CancelledError را throw() می‌کنیم. 
</li>
<li>
مطابق انتظار، می‌بینیم که پیام مربوط به توقف نوشته می‌شود.
</li>
<li>
تابع coroutine به صورت صحیحی تمام می‌شود (به یاد آورید که استثنای StopIteration طریق معمول اتمام کار coroutine هاست).
</li>
</ol>

برای رساندن این نکته به سرمنزل مقصود، که «متوقف‌سازی تسک» چزی بیشتر از ایجاد و مدیریت عادی استثناها نیست، مثال 3-10 را ببینید، که در آن متوقف‌سازی را پله کرده و به coroutine دیگری منتقل می‌شویم.

مثال 3-10. فقط به جهت آموزش - این کار را انجام ندهید!

```python
>>> async def f():
...     try:
...         while True: await asyncio.sleep(0)
...     except asyncio.CancelledError:
...         print('Nope!')
...         while True: await asyncio.sleep(0) #1
...     else:
...         return 111
>>> coro = f()
>>> coro.send(None)
>>> coro.throw(asyncio.CancelledError) #2
Nope!
>>> coro.send(None) #3
```

<ol>
<li>
به جای نوشتن یک پیام، چه اتفاقی می‌افتد اگر پس از متوقف‌سازی، به عقب برگردیم و منتظر یک awaitable دیگر بمانیم؟
</li>
<li>
جای تعجب ندارد که، coroutine بیرونی به حیات ادامه داده و بلافاصله دوباره در coroutine جدید معلق می‌شود. 
</li>
<li>
همه چیز عادی صورت می‌گیرد و coroutine مطابق انتظار معلق می‌شود و به کار ادامه می‌دهد. 
</li>
</ol>

البته، شایان ذکر است که هرگز نباید چنین کنید! اگر coroutine شما یک سیگنال متوقف‌شدن دریافت کند، دستوری واضح دریافت کرده که تنها پاک‌سازی‌های لازم را انجام داده و تمام شود. به این بی‌توجهی نکنید!

تا به این‌جا، بسیار خسته‌کننده است که با فراخوانی دستی .send(None) نقش یک حلقه‌ی event را بازی کنید. بنابراین در مثال 3-11، حلقه‌ی event موجود در asyncio را به کار گرفته و مثال قبلی را قدری تمیزتر ارائه می‌کنیم.

```python
>>> async def f():
...     await asyncio.sleep(0)
...     return 111
>>> loop = asyncio.get_event_loop() #1
>>> coro = f()
>>> loop.run_until_complete(coro) #2
111
```

<ol>
<li>
یک حلقه ایجاد کنید.
</li>
<li>
تابع coroutine را تا سرانجامش اجرا کنید. پشت صحنه، تمام .send(None) ها برای ما فراخوانی می‌شود و اتمام coroutine را با استثنای StopIteration که مقدار بازگشتی را در خود دارد، شناسایی می‌کند.
</li>
</ol>

## حلقه‌ی event

در بخش قبل نشان دادیم که متدهای send() و throw() چگونه با یک coroutine تعامل می‌کنند، اما تنها برای این بود که متوجه شود خود coroutineها چگونه ساختار یافته‌اند. حلقه‌ی event در asyncio تمام جابه‌جایی‌ها بین coroutine ها را، به همراه به دام انداختن استثناهای StopIteration و موارد بیشتری چون گوش‌کردن به سوکت‌ها و فایل دیسکریپتورها برای eventها، مدیریت می‌کند.

شما می‌تواند بدون کارکردن مستقیم با event loopها به کار خود برسید: کد asyncioی شما می‌تواند تماما با استفاده از فراخوانی‌های `await` که با `asyncio.run(coro)` ایجاد می‌شود، نوشته‌شود. با این حال، گاهی درجاتی از تعامل با event loop نیاز است، و در این بخش توضیح می‌دهیم که چگونه حلقه را ایجاد کنید.

دو راه داریم:

_**پیشنهادی**_

> استفاده از `asyncio.get_running_loop()`، که در بدنه coroutine قابل فراخوانی باشد

_**غیرپیشنهادی**_

> استفاده از `asyncio.get_event_loop()`، از هرجا قابل فراخوانی باشد

راه غیرپیشنهادی را در بسیاری از کدها می‌توان دید، چرا که تابع جدیدتر `get_running_loop()` بسیار بعدتر، در پایتون 3.8 معرفی شد. بنابراین، سودمند است که در عمل ایده‌ای از کارکرد روش غیرپیشنهادی داشته باشیم. با مثال 3-12 شروع می‌کنیم.

مثال 3-12. دریافت همان حلقه‌ی event اولیه در هرزمان

```python
>>> loop = asyncio.get_event_loop()
>>> loop2 = asyncio.get_event_loop()
>>> loop is loop2 #1
True
```

<ol>
<li>
هر دو شناسه، loop و loop2، به یک شئ اشاره می‌کنند.
</li>
</ol>

این بدان معناست که اگر درون یک تابع coroutine باشید و نیاز به دسترسی به حلقه داشته باشید، می‌توانید `get_event_loop()‍` را فراخوانی کنید. نیازی به انتقال واضح یک پارامتر حلقه به تمام توابع خود نداریم.

شرایط در صورتی که طراح فریم‌ورک باشید فرق می‌کند: بهتر است صرفا جهت جلوگیری از شرایطی که در آن، کاربران کاری غیر معمول با [سیاست‌های event loop](https://docs.python.org/3/library/asyncio-policy.html#asyncio-policies) انجام دهند، توابع خود را به گونه‌ای طراحی کنید که یک پارامتر حلقه بپذیرند. این سیاست‌ها از بحث این کتاب خارج هستند و چیز بیشتری در باره‌ی آن‌ها گفته نخواهدشد.

پس اگر `get_event_loop()` و `get_running_loop()` مانند هم کار می‌کنند، چرا هر دوی آن‌ها را داریم؟ چرا که `get_event_loop()` تنها در حوزه‌ی یک thread کار می‌کند. در واقع،‌ `get_event_loop()` در یک thread جدید کار نمی‌کند، مگر این که یک حلقه‌ی جدید با `new_event_loop()` ایجاد کنید و این حلقه‌ی جدید را برای آن thread با `set_event_loop()` تنظیم کنید. بیشتر ما تنها به یک حلقه و یک thread نیاز داریم. thread که آن را در بر بگیرد، نیاز داریم (در واقع، خواستار آنیم!).

در مقابل، `get_running_loop()` (متد پیشنهادی) همیشه کاری را که از آن انتظار می‌رود انجام می‌دهد، چرا که آن را تنها می‌توان در چارچوب یک coroutine، یا یک تسک، یا تابعی که این دو فرابخوانند، می‌توان فراخواند. همیشه حلقه‌ی در حال اجرای فعلی را برمی‌گرداند که تقریبا همان مطلوب ماست.

معرفی `get_running_loop()` هم‌چنین، ایجاد تسک‌های پشت صحنه را ساده‌تر کرده‌است. مثال 3-13 را در نظر بگیرید: این مثال شامل یک تابع coroutine است که درون آن تسک‌های اضافه‌ای ایجاد شده که در صف انتظار قرار نگرفته‌اند.

مثال 3-13. ایجاد تسک

```python
async def f():
    # Create some tasks!
    loop = asyncio.get_event_loop()
for i in range():
    loop.create_task(<some other coro>)
```

در مثال بالا، می‌خواهیم تسک‌های کاملا جدیدی درون coroutine استفاده کنیم. با قرار ندادن آن‌ها در صف انتظار، اطمینان حاصل می‌شود که آن‌ها مستقل از چارچوب اجرای تابع f()، یک coroutine، اجرا می‌شوند. در واقع، f() پیش از اتمام تسک‌هایی که ایجاد کرده، خاتمه می‌یابد.

پیش از پایتون 3.7، مهم بود که ابتدا حلقه را برای برنامه‌ریزی یک تسک ساخت، اما با معرفی get_running_loop()، دیگر توابع asyncio مانند asyncio.create_task() برای استفاده از آن به میدان آمدند. پس از پایتون 3.7 تا به الان، کدی که یک تسک async را می‌سازد به شکل زیر است:

```python
import asyncio
async def f():
    # Create some tasks!
    for i in range():
        asyncio.create_task(<some other coro>)
```

این امکان نیز وجود دارد که تابع سطح پایین دیگری به نام `asyncio.ensure_future()` را به کار گرفت تا تسک‌ها را مشابه create_task() بسازد. این صورت را هم‌چنان در کدهای قدیمی‌تر asyncio می‌توان دید. من به این فکر می‌کردم که از توضیح `ensure_future()` صرف نظر کنم، اما این مورد، بهترین مثال است که نشان دهد asyncio تنها برای طراحان فریم‌ورک بوده، و سیاق سابق این ماژول را برای توسعه‌دهندگان اپلیکیشن سخت‌فهم کرده است. تفاوت میان `asyncio.create_task()` و `asyncio.ensure_feature` بسیار ریز است و برای بسیاری از مبتدیان گیج‌کننده است. این تفاوت‌ها را در بخش بعد بررسی می‌کنیم.
